{
  "hash": "c956ce10c08d315f49c16c057db3ae7d",
  "result": {
    "markdown": "---\ntitle: \"Apply functions with purrr :: Cheatsheet\"\ndescription: \" \"\nimage-alt: \"\"\nexecute:\n  eval: true\n  output: false\n  message: true\n---\n\n::: {.cell .column-margin}\n<img src=\"images/logo-purrr.png\" height=\"138\" alt=\"Hex logo for purrr - a simple sketch of a sleeping cat nestled into the bottom of the black border of the hexagon. 'purrr' is written across the top in black.\" />\n<br><br><a href=\"../purrr.pdf\">\n<p><i class=\"bi bi-file-pdf\"></i> Download PDF</p>\n<img src=\"../pngs/purrr.png\" width=\"200\" alt=\"\"/>\n</a>\n<br><br><p>Translations (PDF)</p>\n* <a href=\"../translations/korean/purrr_ko.pdf\"><i class=\"bi bi-file-pdf\"></i>Korean</a>\n* <a href=\"../translations/russian/purrr_ru.pdf\"><i class=\"bi bi-file-pdf\"></i>Russian</a>\n* <a href=\"../translations/spanish/purrr_es.pdf\"><i class=\"bi bi-file-pdf\"></i>Spanish</a>\n* <a href=\"../translations/ukrainian/purrr_uk.pdf\"><i class=\"bi bi-file-pdf\"></i>Ukrainian</a>\n* <a href=\"../translations/vietnamese/purrr_vi.pdf\"><i class=\"bi bi-file-pdf\"></i>Vietnamese</a>\n:::\n\n\npurrr enhances R's functional programming (FP) toolkit by providing a complete and consistent set of tools for working with functions and vectors.\nIf you've never heard of FP before, the best place to start is the family of [`map()`](https://purrr.tidyverse.org/reference/map.html) functions which allow you to replace many for loops with code that is both more succinct and easier to read.\nThe best place to learn about the [`map()`](https://purrr.tidyverse.org/reference/map.html) functions is the [iteration chapter](https://r4ds.had.co.nz/iteration.html) in R for Data Science.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(purrr)\n```\n:::\n\n\n<!-- Page 1 -->\n\n## Map Functions\n\n### One List\n\n-   `map(.x, .f, ...)`: Apply a function to each element of a list of vector, and return a list.\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    x <- list(a = 1:10, b = 11:20, c = 21:30)\n    l1 <- list(x = c(\"a\", \"b\"), y = c(\"c\", \"d\"))\n    map(l1, sort, decreasing = TRUE)\n    ```\n    :::\n\n\n-   `map_dbl(.x, .f, ...)`: Return a double vector.\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    map_dbl(x, mean)\n    ```\n    :::\n\n\n-   `map_int(.x, .f, ...)`: Return an integral vector.\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    map_int(x, length)\n    ```\n    :::\n\n\n-   `map_chr(.x, .f, ...)`: Return a character vector.\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    map_chr(l1, paste, collapse = \"\")\n    ```\n    :::\n\n\n-   `map_lgl(.x, .f, ...)`: Return a logical vector.\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    map_lgl(x, is.integer)\n    ```\n    :::\n\n\n-   `map_dfc(.x, .f, ...)`: Return a data frame created by column-binding.\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    map_dfc(l1, rep, 3)\n    ```\n    :::\n\n\n-   `map_dfr(.x, .f, ...)`: Return a data frame created by row-binding.\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    map_dfr(x, summary)\n    ```\n    :::\n\n\n-   `walk(.x, .f, ...)`: Trigger side effects, return invisibly.\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    walk(x, print)\n    ```\n    :::\n\n\n### Two Lists\n\n-   `map2(.x, .y, .f, ...)`: Apply a function pairs of elements from two lists or vectors, return a list.\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    y <- list(1, 2, 3)\n    z <- list(4, 5, 6)\n    l2 <- list(x = \"a\", y = \"z\")\n    map2(x, y, ~ .x * .y)\n    ```\n    :::\n\n\n-   `map2_dbl(.x, .y, .f, ...)`: Return a double vector.\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    map2_dbl(y, z, ~ .x / .y)\n    ```\n    :::\n\n\n-   `map2_int(.x, .y, .f, ...)`: Return an integral vector.\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    map2_int(y, z, `+`)\n    ```\n    :::\n\n\n-   `map2_chr(.x, .y, .f, ...)`: Return a character vector.\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    map2_chr(l1, l2, paste, collapse = \",\", sep = \":\")\n    ```\n    :::\n\n\n-   `map2_lgl(.x, .y, .f, ...)`: Return a logical vector.\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    map2_lgl(l2, l1, `%in%`)\n    ```\n    :::\n\n\n-   `map2_dfc(.x, .y, .f, ...)`: Return a data frame created by column-binding.\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    map2_dfc(l1, l2, ~ as.data.frame(c(.x, .y)))\n    ```\n    :::\n\n\n-   `map2_dfr(.x, .y, .f, ...)`: Return a data frame created by row-binding.\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    map2_dfr(l1, l2, ~ as.data.frame(c(.x, .y)))\n    ```\n    :::\n\n\n-   `walk2(.x, .y, .f, ...)`: Trigger side effects, return invisibly.\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    walk2(objs, paths, save)\n    ```\n    :::\n\n\n### Many Lists\n\n-   `pmap(.l, .f, ...)`: Apply a function to groups of elements from a list of lists or vectors, return a list.\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    pmap(list(x, y, z), ~ ..1 * (..2 + ..3))\n    ```\n    :::\n\n\n-   `pmap_dbl(.l, .f, ...)`: Return a double vector.\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    pmap_dbl(list(y, z), ~ .x / .y)\n    ```\n    :::\n\n\n-   `pmap_int(.l, .f, ...)`: Return an integral vector.\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    pmap_int(list(y, z), `+`)\n    ```\n    :::\n\n\n-   `pmap_chr(.l, .f, ...)`: Return a character vector.\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    pmap_chr(list(l1, l2), paste, collapse = \",\", sep = \":\")\n    ```\n    :::\n\n\n-   `pmap_lgl(.l, .f, ...)`: Return a logical vector.\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    pmap_lgl(list(l2, l1), `%in%`)\n    ```\n    :::\n\n\n-   `pmap_dfc(.l, .f, ...)`: Return a data frame created by column-binding.\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    pmap_dfc(list(l1, l2), ~ as.data.frame(c(.x, .y)))\n    ```\n    :::\n\n\n-   `pmap_dfr(.l, .f, ...)`: Return a data frame created by row-binding.\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    pmap_dfr(list(l1, l2), ~ as.data.frame(c(.x, .y)))\n    ```\n    :::\n\n\n-   `pwalk(.l, .f, ...)`: Trigger side effects, return invisibly.\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    pwalk(list(objs, paths), save)\n    ```\n    :::\n\n\n### Lists and Indexes\n\n-   `imap(.x, .f, ...)`: Apply `.f` to each element and its index, return a list.\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    imap(y, ~ paste0(.y, \": \", .x))\n    ```\n    :::\n\n\n-   `imap_dbl(.x, .f, ...)`: Return a double vector.\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    imap_dbl(y, ~ .y)\n    ```\n    :::\n\n\n-   `imap_int(.x, .f, ...)`: Return an integral vector.\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    imap_int(y, ~ .y)\n    ```\n    :::\n\n\n-   `imap_chr(.x, .f, ...)`: Return a character vector.\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    imap_chr(y, ~ paste0(.y, \": \", .x))\n    ```\n    :::\n\n\n-   `imap_lgl(.x, .f, ...)`: Return a logical vector.\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    imap_lgl(l1, ~ is.character(.y))\n    ```\n    :::\n\n\n-   `imap_dfc(.x, .f, ...)`: Return a data frame created by column-binding.\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    imap_dfc(l2, ~ as.data.frame(c(.x, .y)))\n    ```\n    :::\n\n\n-   `imap_dfr(.x, .f, ...)`: Return a data frame created by row-binding.\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    imap_dfr(l2, ~ as.data.frame(c(.x, .y)))\n    ```\n    :::\n\n\n-   `iwalk(.x, .f, ...)`: Trigger side effects, return invisibly.\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    iwalk(z, ~ print(paste0(.y, \": \", .x)))\n    ```\n    :::\n\n\n## Function Shortcuts\n\n-   Use `~ .` with functions like `map()` that have single arguments.\n    `map(l, ~ . + 2)` becomes `map(l, function(x) x + 2)`.\n\n-   Use `~ .x .y` with functions like `map2()` that have two arguments.\n    `map2(l, p, ~ .x + .y)` becomes `map2(l, p, function(l, p) l + p)`.\n\n-   Use `~ ..1 ..2 ..3` etc with functions like `pmap()` that have many arguments.\n    `pmap(list(a, b, c), ~ ..3 + ..1 - ..2)` becomes `pmap(list(a,b,c), function(a, b, c) c + a - b)`.\n\n-   Use `~ .x .y` with functions like `imap()`.\n    `.x` will get the list value and `.y` with get the index, or name if available.\n    `imap(list(a, b, c), ~ paste0(.y, \": \", .x))` outputs `index: value` for each item.\n\n-   Use a `string` or `integer` with any map function to index list elements by name or position.\n    `map(l, \"name\")` becomes `map(l, function(x) x[[\"name\"]])`.\n\n<!-- Page 2 -->\n\n## Work with Lists\n\n### Filter\n\n-   `keep(.x, .p, ...)`: Select elements that pass a logical test.\n    Conversely `discard()`.\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    keep(x, is.numeric)\n    ```\n    :::\n\n\n-   `compact(.x, .p = identity)`: Drop empty elements.\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    compact(x)\n    ```\n    :::\n\n\n-   `head_while(.x, .p, ...)`: Return head elements until one does not pass.\n    Also `tail_while()`.\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    head_while(x, is.character)\n    ```\n    :::\n\n\n-   `detect(.x, .f, ..., dir = c(\"forward\", \"backward\"), .right = NULL)`: Find first element to pass.\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    detect(x, is.character)\n    ```\n    :::\n\n\n-   `detect_index(.x, .f, ..., dir = c(\"forward\", \"backward\"), .right = NULL)`: Find index of first element to pass.\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    detect_index(x, is.character)\n    ```\n    :::\n\n\n-   `every(.x, .p, ...)`: Do all elements pass a test?\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    every(x, is.character)\n    ```\n    :::\n\n\n-   `some(.x, .p, ...)`: Do some elements pass a test?\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    some(x, is.character)\n    ```\n    :::\n\n\n-   `none(.x, .p, ...)`: Do no elements pass a test?\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    none(x, is.character)\n    ```\n    :::\n\n\n-   `has_element(.x, .y)`: Does a list contain an element?\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    has_element(x, \"foo\")\n    ```\n    :::\n\n\n-   `pluck_depth(x)`: Return depth (number of levels of indexes).\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    pluck_depth(x)\n    ```\n    :::\n\n\n### Index\n\n-   `pluck(.x, ..., .deault = NULL)`: Select an element by name or index.\n    Also `attr_getter()` and `chuck()`.\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    pluck(x, \"b\")\n    x |> pluck(\"b\")\n    ```\n    :::\n\n\n-   `assign_in(x, where, value)`: Assign a value to a location using pluck selection.\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    assign_in(x, \"b\", 5)\n    x |> assign_in(\"b\", 5)\n    ```\n    :::\n\n\n-   `modify_in(.x, .where,, .f)`: Apply a function to a value at a selected location.\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    modify_in(x, \"b\", abs)\n    ```\n    :::\n\n\n### Reshape\n\n-   `flatten(.x)`: Remove a level of indexes from a list.\n    Also `flatten_chr()` etc.\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    flatten(x)\n    ```\n    :::\n\n\n-   `array_tree(array, margin = NULL)`: Turn array into list.\n    Also `array_branch()`.\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    z <- array(1:12, c(2, 2, 2))\n    array_tree(z, margin = 3)\n    ```\n    :::\n\n\n-   `transpose(.l, .names = NULL)`: Transposes the index order in a multi-level list.\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    transpose(x)\n    ```\n    :::\n\n\n-   `set_names(x, nm = x)`: Set the names of a vector/list directly or with a function.\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    set_names(x, c(\"p\", \"q\", \"r\"))\n    set_names(x, tolower)\n    ```\n    :::\n\n\n### Modify\n\n-   `modify(.x, .f, ...)`: Apply a function to each element.\n    Also `modify2()` and `imodify()`.\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    modify(x, ~ . + 2)\n    ```\n    :::\n\n\n-   `modify_at(.x, .at, .f, ...)`: Apply a function to selected elements.\n    Also `map_at()`.\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    modify_at(x, \"b\", ~ . + 2)\n    ```\n    :::\n\n\n-   `modify_if(.x, .p, .f, ...)`: Apply a function to elements that pass a test.\n    Also `map_if()`.\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    modify_if(x, is.numeric, ~ . + 2)\n    ```\n    :::\n\n\n-   `modify_depth(.x, .depth, .f, ...)`: Apply function to each element at a given level of a list.\n    Also `map_depth()`.\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    modify_depth(x, 1, ~ . + 2)\n    ```\n    :::\n\n\n### Reduce\n\n-   `reduce(.x, .f, ..., .init, .dir = c(\"forward\", \"backward\"))`: Apply function recursively to each element of a list of vector.\n    Also `reduce2()`.\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    a <- list(1, 2, 3, 4)\n    reduce(a, sum)\n    ```\n    :::\n\n\n-   `accumulate(.x, .f, ..., .init)`: Reduce a list, but also return intermediate results in a list.\n    Also `accumulate2()`.\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    a <- list(1, 2, 3, 4)\n    accumulate(a, sum)\n    ```\n    :::\n\n\n### List-Columns\n\n**List-columns** are columns of a data frame where each element is a list or vector instead of an atomic value.\nColumns can also be lists of data frames.\nSee **tidyr** for more about nested data and list columns.\n\n#### Work With List-Columns\n\nManipulate list-columns like any other kind of column, using **dplyr** functions like `mutate()` and `transmute()`.\nBecause each element is a list, use **map functions** within a column function to manipulate each element.\n\n-   `map()`, `map2()`, or `pmap()` return lists and will **create new list-columns**.\n    In this example, `transmute()` is a column function, `map2()` is a list function which returns a list, and `vehicles` and `starships` are list-columns.\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    dplyr::starwars |>\n      dplyr::mutate(ships = map2(vehicles, starships, append))\n    ```\n    :::\n\n\n-   Suffixed map functions like `map_int()` return an atomic data type and will **simplify list-columns into regular columns**.\n    In this example, `mutate()` is a column function, `map_int()` is a list function which returns a column vector, and `films` is a list column.\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    dplyr::starwars |>\n      dplyr::mutate(n_films = map_int(films, length))\n    ```\n    :::\n\n\n------------------------------------------------------------------------\n\nCC BY SA Posit Software, PBC • [info\\@posit.co](mailto:info@posit.co) • [posit.co](https://posit.co)\n\nLearn more at [purrr.tidyverse.org](https://purrr.tidyverse.org).\n\nUpdated: 2023-06.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npackageVersion(\"purrr\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] '1.0.1'\n```\n:::\n:::\n\n\n------------------------------------------------------------------------\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}